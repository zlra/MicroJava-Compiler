package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
	
	//kada ne mozemo da nastavimo dalje     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
  	//prijavljujemo gresku i nastavljamo dalje
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
  	//ne mozemo da se oporavimo od greske
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROGRAM, BREAK, CLASS, ELSE, IF, NEW, PRINT, READ, RETURN, VOID, DO, WHILE, EXTENDS, CONTINUE ;
terminal String IDENT ; 
terminal Integer NUMCONSTANT ;
terminal Character CHARCONSTANT ;
terminal BOOLCONSTANT ;
terminal PLUS, MINUS, MUL, DIV, MOD, EQ, NEQ, LT, LTE, GT, GTE, AND, OR, ASSIGN, INC, DEC, SEMI, COMMA, DOT, LRBRACKET, RRBRACKET, LSBRACKET, RSBRACKET, LCBRACKET, RCBRACKET ;
terminal CONST ;

non terminal DeclarationList DeclarationList;
nonterminal DeclarationListElement DeclarationListElement ;
non terminal ConstDecl ConstDecl;
nonterminal ConstChoice ConstChoice;
nonterminal ConstChoiceList ConstChoiceList ;
non terminal VarDecl VarDecl;
nonterminal OptionalBrackets OptionalBrackets ;
non terminal ClassDecl ClassDecl;
nonterminal OptionalExtend OptionalExtend;
nonterminal ClassBody ClassBody;
nonterminal ClassVarDeclarations ClassVarDeclarations;
nonterminal OptionalMethodDeclarations OptionalMethodDeclarations;
non terminal MethodDeclList MethodDeclList ; 
non terminal FormalParamList FormalParamList;
nonterminal FormalParamDecl FormalParamDecl ;
non terminal StatementList StatementList;
nonterminal Statement Statement;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal Condition Condition;
nonterminal OptionalElseStatement OptionalElseStatement;
nonterminal OptionalExpression OptionalExpression;
nonterminal OptionalNumConst OptionalNumConst ;
non terminal DesignatorStatementBodyOptional DesignatorStatementBodyOptional;
nonterminal DesignatorList DesignatorList;
nonterminal OptionalActParams OptionalActParams;
nonterminal ActParams ActParams ;
non terminal CondTerm CondTerm;
nonterminal CondFact CondFact;
nonterminal OptionalRelopExpr OptionalRelopExpr;
nonterminal OptionalMinus OptionalMinus;
nonterminal OptionalOptionalActParams OptionalOptionalActParams;
nonterminal OptionalBracketExpr OptionalBracketExpr ;
non terminal Relop Relop;
nonterminal Addop Addop;
nonterminal Mulop Mulop ;

non terminal Program Program;
nonterminal ProgName ProgName;
nonterminal Designator Designator;
nonterminal MethodDecl MethodDecl;
nonterminal MethodTypeName MethodTypeName; 
non terminal Type Type;
nonterminal Term Term;
nonterminal Expr Expr;
nonterminal Factor Factor;
nonterminal VarDeclList VarDeclList; 
non terminal OptionalFormParams OptionalFormParams;
nonterminal AddOpTermList AddOpTermList ;

precedence left ELSE;

Program ::= (Program) PROGRAM ProgName:P1 DeclarationList:D2 LCBRACKET MethodDeclList:M3 RCBRACKET {: RESULT=new Program(P1, D2, M3); RESULT.setLine(P1left); :}
;

ProgName ::= (ProgName) IDENT:I1 {: RESULT=new ProgName(I1); RESULT.setLine(I1left); :} 
;

DeclarationList ::= (DeclarationListNotEmpty) DeclarationList:D1 DeclarationListElement:D2 {: RESULT=new DeclarationListNotEmpty(D1, D2); RESULT.setLine(D1left); :}
					|
					(DeclarationListEmpty) {: RESULT=new DeclarationListEmpty(); :} /* epsilon */
					;

DeclarationListElement ::= (DeclarationListConstElement) ConstDecl:C1 {: RESULT=new DeclarationListConstElement(C1); RESULT.setLine(C1left); :}
						   |
						   (DeclarationListVarElement) VarDecl:V1 {: RESULT=new DeclarationListVarElement(V1); RESULT.setLine(V1left); :}
						   |
						   (DeclarationListClassElement) ClassDecl:C1 {: RESULT=new DeclarationListClassElement(C1); RESULT.setLine(C1left); :}
						   ;
						   
ConstDecl ::= (ConstDecl) CONST Type:T1 IDENT:I2 ASSIGN ConstChoice:C3 ConstChoiceList:C4 SEMI {: RESULT=new ConstDecl(T1, I2, C3, C4); RESULT.setLine(T1left); :}
;

ConstChoice ::= (ConstChoiceNum) NUMCONSTANT:N1 {: RESULT=new ConstChoiceNum(N1); RESULT.setLine(N1left); :} 
				|
				(ConstChoiceChar) CHARCONSTANT:C1 {: RESULT=new ConstChoiceChar(C1); RESULT.setLine(C1left); :}
				|
				(ConstChoiceBool) BOOLCONSTANT {: RESULT=new ConstChoiceBool(); :}
				;

ConstChoiceList ::= (ConstChoiceListNotEmpty) ConstChoiceList:C1 COMMA IDENT:I2 ASSIGN ConstChoice:C3 {: RESULT=new ConstChoiceListNotEmpty(C1, I2, C3); RESULT.setLine(C1left); :}
					|
					(ConstChoiceListEmpty) {: RESULT=new ConstChoiceListEmpty(); :} /* epsilon */ 
					;
					
VarDecl ::= (VarDecl) Type:T1 IDENT:I2 OptionalBrackets:O3 VarDeclList:V4 SEMI {: RESULT=new VarDecl(T1, I2, O3, V4); RESULT.setLine(T1left); :}
;


OptionalBrackets ::= (Brackets) LSBRACKET RSBRACKET {: RESULT=new Brackets(); :}
					 |
					 (NoBrackets) {: RESULT=new NoBrackets(); :} /* epsilon */
					 ;

VarDeclList ::= (VarDeclListNotEmpty) VarDeclList:V1 COMMA IDENT:I2 OptionalBrackets:O3 {: RESULT=new VarDeclListNotEmpty(V1, I2, O3); RESULT.setLine(V1left); :} 
				|
				(VarDeclListEmpty) {: RESULT=new VarDeclListEmpty(); :} /* epsilon */
				;

ClassDecl ::= (ClassDecl) CLASS IDENT:I1 OptionalExtend:O2 ClassBody:C3 {: RESULT=new ClassDecl(I1, O2, C3); RESULT.setLine(I1left); :}
;

OptionalExtend ::= (OptionalExtendExists) EXTENDS Type:T1 {: RESULT=new OptionalExtendExists(T1); RESULT.setLine(T1left); :}
				   |
				   (OptionalExtendNotExist) {: RESULT=new OptionalExtendNotExist(); :} /* epsilon */
				   ;

ClassBody ::= (ClassBody)  LCBRACKET ClassVarDeclarations:C1 OptionalMethodDeclarations:O2 RCBRACKET {: RESULT=new ClassBody(C1, O2); RESULT.setLine(C1left); :};

ClassVarDeclarations ::= (ClassVarDeclarationsNotEmpty) ClassVarDeclarations:C1 VarDecl:V2 {: RESULT=new ClassVarDeclarationsNotEmpty(C1, V2); RESULT.setLine(C1left); :}
						 | 
						 (ClassVarDeclarationEmpty) {: RESULT=new ClassVarDeclarationEmpty(); :} /* epsilon */
						 ;
						 
OptionalMethodDeclarations ::= (OptionalMethodDeclarationsNotEmpty) LCBRACKET MethodDeclList:M1 RCBRACKET {: RESULT=new OptionalMethodDeclarationsNotEmpty(M1); RESULT.setLine(M1left); :} 
							   |
							   (OptionalMethodDeclarationsEmpty) {: RESULT=new OptionalMethodDeclarationsEmpty(); :} /* epsilon */
							   ;

Type ::= (Type) IDENT:I1 {: RESULT=new Type(I1); RESULT.setLine(I1left); :}
;
				   
MethodDeclList ::= (MethodDeclarationsNotEmpty) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclarationsNotEmpty(M1, M2); RESULT.setLine(M1left); :}
				   |
				   (MethodDeclarationsEmpty) {: RESULT=new MethodDeclarationsEmpty(); :}/* epsilon */
				   ;

MethodDecl ::= (MethodDecl) MethodTypeName:M1 IDENT:I2 
			   LRBRACKET OptionalFormParams:O3 RRBRACKET ClassVarDeclarations:C4 LCBRACKET StatementList:S5 RCBRACKET {: RESULT=new MethodDecl(M1, I2, O3, C4, S5); RESULT.setLine(M1left); :}
			   ;

MethodTypeName ::= (MethodTypeNameNotVoid) IDENT:I1 {: RESULT=new MethodTypeNameNotVoid(I1); RESULT.setLine(I1left); :} 
				   | 
				   (MethodTypeNameVoid) VOID {: RESULT=new MethodTypeNameVoid(); :}
				   ;
				   
OptionalFormParams ::= (FormParamsNotEmpty) FormalParamList:F1 {: RESULT=new FormParamsNotEmpty(F1); RESULT.setLine(F1left); :} | (FormParamsEmpty) {: RESULT=new FormParamsEmpty(); :} /* epsilon */ ;

FormalParamList ::= (MultiFormalParamDeclarations) FormalParamList:F1 COMMA FormalParamDecl:F2 {: RESULT=new MultiFormalParamDeclarations(F1, F2); RESULT.setLine(F1left); :}
					|
					(SingleFormalParamDeclaration) FormalParamDecl:F1 {: RESULT=new SingleFormalParamDeclaration(F1); RESULT.setLine(F1left); :}
					;
					
FormalParamDecl ::= (FormalParamDecl) Type:T1 IDENT:I2 OptionalBrackets:O3 {: RESULT=new FormalParamDecl(T1, I2, O3); RESULT.setLine(T1left); :} ;

StatementList ::= (StatementListEmpty) StatementList:S1 Statement:S2 {: RESULT=new StatementListEmpty(S1, S2); RESULT.setLine(S1left); :} 
					|
				  (StatementListNotEmpty) {: RESULT=new StatementListNotEmpty(); :} /* epsilon */
				  ;

Statement ::= (DesigStatement) DesignatorStatement:D1 SEMI {: RESULT=new DesigStatement(D1); RESULT.setLine(D1left); :} 
			  | 
			  (IfStatement) IF LRBRACKET Condition:C1 RRBRACKET Statement:S2 OptionalElseStatement:O3 {: RESULT=new IfStatement(C1, S2, O3); RESULT.setLine(C1left); :}
			  |
			  (DoStatement) DO Statement:S1 WHILE LRBRACKET Condition:C2 RRBRACKET SEMI {: RESULT=new DoStatement(S1, C2); RESULT.setLine(S1left); :}
			  |
			  (BreakStatement) BREAK SEMI {: RESULT=new BreakStatement(); :}
			  |
			  (ContinueStatement) CONTINUE SEMI {: RESULT=new ContinueStatement(); :}
			  |
			  (ReturnStatement) RETURN OptionalExpression:O1 SEMI {: RESULT=new ReturnStatement(O1); RESULT.setLine(O1left); :}
			  |
			  (ReadStatement) READ LRBRACKET Designator:D1 RRBRACKET SEMI {: RESULT=new ReadStatement(D1); RESULT.setLine(D1left); :}
			  |
			  (PrintStatement) PRINT LRBRACKET Expr:E1 OptionalNumConst:O2 RRBRACKET SEMI {: RESULT=new PrintStatement(E1, O2); RESULT.setLine(E1left); :}
			  |
			  (ListStatement) LCBRACKET StatementList:S1 RCBRACKET {: RESULT=new ListStatement(S1); RESULT.setLine(S1left); :}
			  ;

OptionalElseStatement ::= (OptionalElseStatementNotEmpty) ELSE Statement:S1 {: RESULT=new OptionalElseStatementNotEmpty(S1); RESULT.setLine(S1left); :} 
						  | 
						  (OptionalElseStatementEmpty) {: RESULT=new OptionalElseStatementEmpty(); :} /* epsilon */
						  ;

DesignatorStatement ::= (DesignatorStatementBody) Designator:D1 DesignatorStatementBodyOptional:D2 {: RESULT=new DesignatorStatementBody(D1, D2); RESULT.setLine(D1left); :}
;

Designator ::= (Designator) IDENT:I1 DesignatorList:D2 {: RESULT=new Designator(I1, D2); RESULT.setLine(I1left); :}
;

DesignatorList ::= (DesignatorListNotEmptyIdent) DesignatorList:D1 DOT IDENT:I2 {: RESULT=new DesignatorListNotEmptyIdent(D1, I2); RESULT.setLine(D1left); :}
				   |
				   (DesignatorListNotEmptyExpr) LSBRACKET Expr:E1 RSBRACKET {: RESULT=new DesignatorListNotEmptyExpr(E1); RESULT.setLine(E1left); :}
				   |
				   (DesignatorListEmpty) {: RESULT=new DesignatorListEmpty(); :} /* epsilon */
				   ;
				   
DesignatorStatementBodyOptional ::= (DesignatorBodyExpression) ASSIGN Expr:E1 {: RESULT=new DesignatorBodyExpression(E1); RESULT.setLine(E1left); :}
									|
									(DesignatorBodyArguments) LRBRACKET OptionalActParams:O1 RRBRACKET {: RESULT=new DesignatorBodyArguments(O1); RESULT.setLine(O1left); :}
									|
									(DesignatorBodyInc) INC {: RESULT=new DesignatorBodyInc(); :}
									|
									(DesignatorBodyDec) DEC {: RESULT=new DesignatorBodyDec(); :}
									;
									
		
OptionalActParams ::= (OptionalActParamsNotEmpty) ActParams:A1 {: RESULT=new OptionalActParamsNotEmpty(A1); RESULT.setLine(A1left); :}
					  | 
					  (OptionalActParamsEmpty) {: RESULT=new OptionalActParamsEmpty(); :} /* epsilon */
					  ;
					  
ActParams ::= (ActParamsList) ActParams:A1 COMMA Expr:E2 {: RESULT=new ActParamsList(A1, E2); RESULT.setLine(A1left); :}
			  | 
			  (ActParam) Expr:E1 {: RESULT=new ActParam(E1); RESULT.setLine(E1left); :}
			  ;
			  
Condition ::= (ConditionList) Condition:C1 OR CondTerm:C2 {: RESULT=new ConditionList(C1, C2); RESULT.setLine(C1left); :}
			  |
			  (ConditionTerm) CondTerm:C1 {: RESULT=new ConditionTerm(C1); RESULT.setLine(C1left); :}
			  ;
			  
CondTerm ::= (CondTermList) CondTerm:C1 AND CondFact:C2 {: RESULT=new CondTermList(C1, C2); RESULT.setLine(C1left); :}
			 |
			 (CondTermFact) CondFact:C1 {: RESULT=new CondTermFact(C1); RESULT.setLine(C1left); :}
			 ;
			 
CondFact ::= (CondFact) Expr:E1 OptionalRelopExpr:O2 {: RESULT=new CondFact(E1, O2); RESULT.setLine(E1left); :}
;
				

OptionalRelopExpr ::= (OptionalRelopExprNotEmpty) Relop:R1 Expr:E2 {: RESULT=new OptionalRelopExprNotEmpty(R1, E2); RESULT.setLine(R1left); :}
					  |
					  (OptionalRelopExprEmpty) {: RESULT=new OptionalRelopExprEmpty(); :} /*epsilon*/
					  ;

Expr ::= OptionalMinus:O1 Term:T2 AddOpTermList:A3 {: RESULT=new ExprDerived1(O1, T2, A3); RESULT.setLine(O1left); :} 
;
	
OptionalMinus ::= (OptionalMinusExists) MINUS {: RESULT=new OptionalMinusExists(); :}
				  |
				  (OptionalMinusNotExists) {: RESULT=new OptionalMinusNotExists(); :} /* epsilon */
				  ;

AddOpTermList ::= (AddOpTermListNotEmpty) AddOpTermList:A1 Addop:A2 Term:T3 {: RESULT=new AddOpTermListNotEmpty(A1, A2, T3); RESULT.setLine(A1left); :}
				  |
				  (AddOpTermListEmpty) {: RESULT=new AddOpTermListEmpty(); :} /* epsilon */
				  ;

Term ::= (TermFactorList) Term:T1 Mulop:M2 Factor:F3 {: RESULT=new TermFactorList(T1, M2, F3); RESULT.setLine(T1left); :}
		 | 
		 (TermFactor) Factor:F1 {: RESULT=new TermFactor(F1); RESULT.setLine(F1left); :}
		 ;
		 
Factor ::= (FactorDesignator) Designator:D1 OptionalOptionalActParams:O2 {: RESULT=new FactorDesignator(D1, O2); RESULT.setLine(D1left); :} 
		   | 
		   (NumConst) NUMCONSTANT:N1 {: RESULT=new NumConst(N1); RESULT.setLine(N1left); :}
		   |
		   (CharConst) CHARCONSTANT:C1 {: RESULT=new CharConst(C1); RESULT.setLine(C1left); :}
		   |
		   (BoolConst) BOOLCONSTANT {: RESULT=new BoolConst(); :} 
		   |
		   (NewFactorExpr) NEW Type:T1 OptionalBracketExpr:O2 {: RESULT=new NewFactorExpr(T1, O2); RESULT.setLine(T1left); :}
		   |
		   (BracketFactorExpr) LRBRACKET Expr:E1 RRBRACKET {: RESULT=new BracketFactorExpr(E1); RESULT.setLine(E1left); :}
		   ;
		   
OptionalBracketExpr ::= (OptionalBracketExprNotEmpty) LSBRACKET Expr:E1 RSBRACKET {: RESULT=new OptionalBracketExprNotEmpty(E1); RESULT.setLine(E1left); :}
						|
						(OptionalBracketExprEmpty) {: RESULT=new OptionalBracketExprEmpty(); :} /* epsilon *////
						;


Relop ::= EQ {: RESULT=new RelopDerived1(); :} | NEQ {: RESULT=new RelopDerived2(); :} | LT {: RESULT=new RelopDerived3(); :} | LTE {: RESULT=new RelopDerived4(); :} | GT {: RESULT=new RelopDerived5(); :} | GTE {: RESULT=new RelopDerived6(); :}
;

Addop ::= PLUS {: RESULT=new AddopDerived1(); :} | MINUS {: RESULT=new AddopDerived2(); :}
;

Mulop ::= MUL {: RESULT=new MulopDerived1(); :} | DIV {: RESULT=new MulopDerived2(); :} | MOD {: RESULT=new MulopDerived3(); :}
;